---
output: 
  pdf_document:
    fig_crop: no
bibliography: "referencias.bib"
nocite: '@*'
link-citations: true
colorlinks: false
fontsize: 11pt
documentclass: article
geometry: 
 - a4paper
 - textwidth=16cm
 - textheight=21cm
header-includes:
  - \usepackage[brazil, english, portuguese]{babel}
  - \usepackage[utf8]{inputenc}
  - \usepackage[T1]{fontenc}
  - \usepackage[fixlanguage]{babelbib}
  - \usepackage{times}
  - \usepackage{caption} 
  - \captionsetup[table]{skip=10pt}
  - \usepackage{amsmath}
  - \usepackage{indentfirst}
indent: true
---

```{=tex}
\begin{titlepage} 

\begin{center} 
{\large Universidade Estadual de Campinas}\\[0.2cm] 
{\large Instituto de Matemática, Estatística e Computação Científica}\\[0.2cm] 
{\large Departamento de Estatística}\\[4cm]

{\bf \huge  Modelo de regressão logística para a predição de estado de saúde animal a partir de variáveis escalares e funcionais}\\[0.5cm]
\line(1,0){450}

{\large Relatório Científico Final do projeto na modalidade Iniciação Científica, fomentado pela Fundação de Amparo à Pesquisa do Estado de São Paulo.}\\[0.5cm]
\line(1,0){450}

{\large Projeto FAPESP: 2020/01436-0}\\[2cm]

{\large Pesquisador Responsável:}\\[0.2cm]
{\large Rodrigo Forti}\\[5cm]

{\large Americana}\\[0.2cm]
{\large 2021}
\end{center}

\end{titlepage}
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, 
                      warning = FALSE,
                      message = FALSE,
                      fig.height = 3, 
                      fig.width = 6, 
                      fig.pos='H',
                      OutDec = ',',
                      comment = NA)


options(OutDec = ",")
```

# Informações Gerais do Projeto

* Título do projeto: Modelo de regressão logística para a predição de estado de saúde animal a partir de variáveis escalares e funcionais

* Nome do pesquisador responsável: Rodrigo Forti

* Instituição sede do projeto: Instituto de Matemática, Estatística e Computação Científica da Universidade Estadual de Campinas

* Equipe de pesquisa: Rodrigo Forti e Mariana Rodrigues Motta

* Número do projeto de pesquisa: 2020/01436-0

* Período de vigência: 01/09/2020 a 31/08/2021

* Período coberto por este relatório científico: 11/02/2021 a 31/08/2021

\newpage

\tableofcontents

\newpage

# Resumo

## Introdução


O período de transição entre o final da gravidez em vacas e o período de lactação precoce (também chamado período periparturiente) é certamente o estágio mais importante do ciclo de lactação destes animais, pois maioria das doenças infecciosas e distúrbios metabólicos ocorre durante esse período. A febre do leite, a cetose, as membranas fetais retidas, a metrite e o abomaso deslocado afetam as vacas diminuindo a produção de leite e prejudicando o seu bem-estar durante o período peripartidário. Há uma maior suscetibilidade para doenças durante o período peri-parturiente que leva, por exemplo, ao aumento de incidência de mastite no animais. Assim, a ocorrência de problemas de saúde se concentra proporcionalmente no período periparturiente, preocupando produtores já que a produção de leite pode diminuir (Drackley, 1999). Como afirmado por Goff and Horst (1997), a transição do estado gestante, não lactante, para o estado não gestante e lactante, é muitas vezes uma experiência desastrosa para a vaca. Alguns problemas de saúde e reprodutivos podem ser resultado do aumento do estresse de que vacas de alta produção estão sob no início da lactação (Kaufman et al. 2018).

Além disso, no início da lactação, a ingestão alimentar é incapaz de atender às demandas de alta produção de leite. A vaca, portanto entra em um período de balanço energético negativo que leva à mobilização de reservas corporais para equilibrar déficit entre consumo de energia dos alimentos e produção de energia do leite (Lago et al. 2001). Lago et al. (2001) também defendem que processo de mobilização parece afetar o bem-estar da vaca e outras vias biológicas comprometidos à medida que a energia de entrada é direcionada para produção.

Assim, a saúde do animal durante o período de lactação é fator determinante na lucratividade dos produtores. Limitações nutricionais ou de manejo durante esse período podem impedir a capacidade da vaca de atingir a produção máxima de leite. Desta forma monitorar índices vitais da vaca, assim como do ambiente onde está inserido, é condição essencial para aprimorar o bem-estar animal e a lucratividade no período de alta incidência de doenças em vacas periparturientes

## Dados

Os dados a serem utilizados neste projeto fazem parte de uma base de dados do laboratório Dairy Cattle Biology and Management da Universidade de Cornell, EUA. Estes dados foram intermediados pelo pesquisador Guilherme Rosa, da University of Wisconsin, EUA, mediante colaboração no projeto FAPESP 2017/15306-9, sob coordenação da Profa. Dra Nancy Lopes Garcia, e tendo como no projeto a Profa. Dra. Mariana Rodrigues Motta.

Os dados foram coletados a partir da análise clínica diária do estado de saúde 500 vacas. Os dados contém informações sobre características individuais das vacas, desempenho em produção de leite e eventos das lactações anteriores e da parição atual. Além disso, os dados foram coleatdos através de múltiplos sensores adaptados ao animal durante 3 sessões diárias para avaliar aspectos do leite, tais como porcentagem de gordura, de proteína, dados de lactose e conductividade, além de dados sobre total de passos dados, tempo de ruminação e tempo de repouso do animal.

Os dados considerados neste estudo devem ser usados para treinar, validar e testar modelos do Sistema de Monitoramento de Saúde Animal (AHMS) do projeto USDA da Dairy Laboratório de Biologia e Gerenciamento de Gado da Universidade de Cornell. Os dados contém informações sobre vacas e leite coletado. O conjunto de dados principal corresponde ao exame clínico diário dos animais são necessários para analisar o período de uma semana antes até três semanas depois do parto em todos os animais. Diariamente, informações de uma vaca sobre um distúrbio de saúde são coletadas.

O estudo de Cornell compreende três fases, Fase I, Fase II e Fase III. O objetivo do estudo da Fase I é caracterizar o padrão de doença, avaliando como os parâmetros mudam com relação ao status do animal. No estudo da Fase II, o foco é desenvolver alertas que sirvam de indicadores aos agricultores quando uma vaca está doente, visando criar uma combinação de vários parâmetros que informam sobre a saúde do animal. A Fase III do estudo compreende a validação dos métodos usados com dados da Fase I, usando ferramentas desenvolvidas em campo em tempo real e, em seguida, avaliando falsos positivos e sensibilidade do método.

A descrição das variáveis do conjunto de dados se encontram na Tabela 1 e 2.

## Objetivos

Neste estudo, os objetivos estão concentrados na Fase I, que busca caracterizar o padrão de doença, avaliando como os parâmetros se comportam com relação ao status do animal. As variáveis utilizadas para modelar a probabilidade do animal estar doente serão consideradas na forma escalar e de função e a ideia é identificar através do ajuste de modelos uma combinação de vários parâmetros que informem sobre a saúde do animal dentro de um determinado período de tempo. Por exemplo, é de interesse predizer a probabilidade de uma animal ficar doente no período de cinco dias após o parto a partir da curva de lactação do período. Para modelar a probabilidade de um animal ficar doente consideramos um modelo de regressão logística com covariáveis escalares (número de inseminações, histórico de doenças, etc) e funções de covariáveis, como por exemplo uma função dos dias em lactação do animal.

```{r variáveis}
library(kableExtra)
library(knitr)

variaveis = data.frame(Variavel = c("ID","DiasLac","DiasRegimeFechado","DiasSecos","NumBezerro","ProdLeite","Gordura",
                                    "Proteina","Lactose","Sangue","NumCelSomaticas",
                                    "TempoRepouso"
                                    ),
                       Unidade = c("Número",
                                   "Dias","Dias","Dias","Número","Gramas", "%",
                                   "%",
                                   "%",
                                   "%",
                                   "*1000/ml",
                                   "Minutos"),
                       Descrição = c(
                                     "Identificação da vaca",
                                     "Dias em lactação (dia 0: dia do parto)",
                                     "Dias em regime Fechado",
                                     "Dias sem produzir leite",
                                     "Número de bezerros nascidos no parto",
                                     "Produção de leite",
                                     "Gordura no leite",
                                     "Proteína no leite",
                                     "Lactose no leite",
                                     "Sangue no leite",
                                     "Número de células somáticas no leite",
                                     "Tempo total de repouso por dia"
                                     ))


variaveis_cont = data.frame(Variavel = c(
                                    "NumRepousos","DuracaoMediaRepouso",
                                    "Atividade","RuminacaoUltimas24h","AlimentacaoUltimas24h",
                                    "Hist_DistDigestivo",
                                    "Hist_Mastite",
                                    "Hist_Claudicao",
                                    "DiasNaoGravida",
                                    "NInseminada",
                                    "DuracaoGestacao",
                                    "DiasPrimeiraParicao",
                                    "DuracaoLacAnterior"),
                       Unidade = c("Número","Minutos","Passos/Hora", "Minutos",
                                   "Gramas",
                                   "0-1",
                                   "0-1",
                                   "0-1",
                                   "Dias",
                                   "Número",
                                   "Dias",
                                   "Dias",
                                   "Dias"),
                       
                       Descrição = c("Número de repousos por dia",
                                     "Duração média do cada repouso",
                                     "Total de passos dados no dia dividido por 24",
                                     "Ruminação total nas últimas 24 horas",
                                     "Quantidade de comida ingerida nas últimas 24 horas",
                                     "Há histórico de distúrbios digestivos - sim(1) não(0)",
                                     "Há histórico de mastite - sim(1) não(0)",
                                     "Há histórico de claudicação - sim(1) não(0)",
                                     "Dias não grávida",
                                     "Número de vezes que a vaca foi inseminada",
                                     "Duração da gestação",
                                     "Idade quando pariu o primeiro bezerro",
                                     "Duração da lactação anterior"))

kable(variaveis, "latex", col.names = c("Variável", "Unidade", "Descrição"),caption = "Descrição das variáveis do conjunto de dados") %>%
  column_spec(3:2, width = "4cm") %>%
  kable_styling(position = "center",latex_options = "HOLD_position")

kable(variaveis_cont, "latex", col.names = c("Variável", "Unidade", "Descrição"),caption = "Descrição das variáveis do conjunto de dados - continuação") %>%
  column_spec(3:2, width = "6cm") %>%
  kable_styling(position = "center",latex_options = "HOLD_position")

```

\newpage

# 1 Modelos estatísticos

Seja $Y_i$ o estado de saúde da vaca i (1 para doente e 0, caso contrário) em um determinado período, e seja $E(Y_i)=p_i$ a probabilidade do animal i estar doente nesse período. Inicialmente ajustamos o modelo de regressão logística (Agresti, 2003) da forma

$$ \textrm{logito}(p_i) = \beta_0 + \sum_{j=1}^{J}\beta_jx_{ij} \tag{1},$$ onde $\textrm{logito}(p_i) = log(p_i/(1-p_i)$, $x_{ij}$ representa a j-ésima variável explicativa da vaca i e $\beta_j$, o efeito desta variável no logito. Para essa abordagem, cada vaca possui uma única observação.

Posteriormente, ajustamos o modelo que acomoda as medidas repetidas de cada animal tomadas entre o dia do parto e 20 dias após este evento. Consideramos um efeito aleatório $u_i \sim N(0,\sigma^2)$ para acomodar a correlação das observações do mesmo animal, devido a repetição de medições das vacas em tempos diferentes. Suponha que $Y_{ik}$ seja o estado de saúde da vaca i (1 para doente e 0, caso contrário) em um determinado dia k, e seja $E(Y_{ik})=p_{ik}$ a probabilidade do animal i estar doente no dia k. Consideramos o ajuste de

$$ \textrm{logito}(p_{ik}) = \beta_0 + \sum_{j=1}^{J}f_j(x_{ij(k-1,k-2)})
+ u_{i} \tag{2}.$$ 

Aqui, $\textrm{logito}(p_{ik}) = log(p_{ik}/(1-p_{ik})$, $f_j(x)$ são funções suaves de $x_{ij(k-1,k-2)}$, $k-1$ e $k-2$ indexam 1 e 2 dias anteriores ao dia k, respectivamente, e $j$ indexa a variável explicativa. A função $f_j(x)$ será estimada através de 

$$\hat{f_j}(x) = \sum_{p=1}^{P}B_p(x)\hat{\theta_p} \tag{3},$$ onde $B_p$ são as funções bases e $\hat{\theta_p}$ seus respectivos coeficientes.

Utilizamos o mecanismo \textit{stepwise} para seleção de variáveis no modelo tendo como critério o AIC (Bozdogan, 1987). O \textit{stepwise} é um processo iterativo para seleção de variáveis explanatórias. Para mais informações sobre o método stepwise, veja Yamashita, Yamashita e Kamimura, 2007. 

Neste trabalho, consideramos um nível de significância igual a 0,05. Para realizar o ajuste da regressão logística em (1) utilizamos a própria função base \textit{glm} do software R (R Core Team, 2019). O modelo em (2) foi ajustado por meio da função \textit{gamm} do pacote \textit{mgcv} do programa R. As funções suaves $f_j(x)$ (3) foram estimadas através da expansão de bases de splines de regressão cúbica pela própria função \textit{gamm}. Na função \textit{gamm}, o modelo é ajustado através da maximização da quasi-verossimilhança penalizada. Para mais informações sobre ajuste de modelos GLM com variáveis funcionais e efeitos aleatórios veja Wood (2017). 

\newpage

# 2 Estrutura e manipulação dos dados

O conjunto de dados utilizado para este trabalho apresenta 71 observações para cada uma das 500 vacas estudadas, coletadas 30 dias antes do parto até 40 dias depois, resultando em um total de 35500 observações.

Além disso, o conjunto de dados apresentou diversos dados faltantes nas covariáveis. Para contornar esse problema tomou-se o seguinte procedimento: se o animal apresentou pelo menos um dado faltante para uma variável, o dado faltante foi substituido pela média dos dados não faltantes. Para o animal sem nenhuma informação numa determinada variável, o valor imputado foi a mediana da variável para as vacas com informação.
 
 
# 3 Validação cruzada 

Para avaliação da capacidade preditiva dos modelos, foi realizada uma validação cruzada com 10 reparticionamentos e com 10 envelopes contendo observações de 50 vacas cada, pois há 500 animais no banco de dados. Em cada repartição, os envelopes foram separados em duas partes: 9 envelopes foram utilizados para o ajuste, i.e. treino, e um envelope foi usado para o verificação de qualidade de predição do modelo, i.e. teste . Veja a Figura 1 que representa um diagrama simplificado da validação cruzada que foi empregado. Para mais informações sobre validação cruzada veja Kohavi (2007).

A forma de checagem da performance do modelo se deu através da área sob a curva da ROC (Bradley, 1997; Ballings and Van den Poel, 2013) e da acurácia (Novaković et al. 2017) no conjunto de teste. A área sob a curva da ROC quantifica a capacidade do modelo em discriminar entre aqueles animais classificados como doentes dado que de fato são doentes e aqueles classificados como sadios. Um modelo com capacidade de predição tão informativo quanto um classificador aleatório tem uma área igual a 0,5, enquanto que um modelo perfeito tem uma área sob a curva igual a 1. Por outro lado, a acurácia indica qual é a porcentagem de predições corretas que o modelo é capaz de realizar.

Com o intuito de avaliar a capacidade de predição do modelo para animais que futuramente venham a fazer parte do local onde foram coletados os dados, simulamos esta situação considerando que animais no conjunto de treino não fazem parte do conjunto de dados para fins de teste simultaneamente. 

As funções do pacote R utilizadas para realizar a validação cruzada e a checagem da qualidade de predição foram desenvolvidas pelo autor do relatório com o auxílio do pacote \textit{Tidyverse} (Wickham et al. 2019). As funções escritas em linguagem R pelo autor se encontram disponíveis no seguinte link: \url{https://github.com/rodrigoforti2000/funcoes-uteis}.


```{r, out.width = "99%", fig.cap="Diagrama simplificado da validação cruzada empregado neste trabalho. O conjunto de dados foi separado em 10 envelopes e em cada envelope há observações de 50 animais. Além disso, não há observações de um mesmo animal em envelopes diferentes. Após isso ocorreu 10 repartições onde 9 envelopes eram utilizados para treino e 1 para o teste do modelo."}
img1_path <- "C:/Users/Windows 10/Documents/GitHub/Final_IC/Treino_1.png"
include_graphics(img1_path)
```

# 4 Resultados

Foram utilizadas duas abordagens  para resolver o problema de classificação entre os dias 0 a 20, após o parto. A primeira abordagem faz o ajuste de um modelo a partir de uma única observação do estado de saúde do animal. A segunda abordagem faz o ajuste de um modelo considerando medidas repetidas de cada animal.

## 4.1 Resultados do ajuste do modelo sem medidas repetidas de saúde da vaca

Como mostra a Figura 2, as vacas ficaram doentes majoritariamente no período entre 5 até 20 dias após o parto. Após esse período, menos de 1% das observações são de vacas em estado doentio, o que dificulta a predição, pois o estado doentio se torna um evento raro. Por isso, trabalhamos apenas com os dados do dia 5 até o dia 20 após o parto.  


```{r pacotes e funcoes}
library(tidyverse)
library(MASS)
library(patchwork)
library(kableExtra)
library(AUC)
library(caret)
library(mgcv)
library(gridExtra)
library(ggpmisc)

#funções
cv_pleno = function(df, n_cv, n_interacao, ID){
  #Definindo semente
  set.seed(42)
  #pega o número de linhas
  length_df = nrow(df)
  length_id = df %>% dplyr::select(ID) %>% n_distinct()
  #embaralha os numeros de linhas e embaralha o banco
  rows <- sample(length_df)
  df = df[rows,]
  #define o tamanho da parte
  size_parte = as.integer(length_id/n_cv)
  #pega os threshold
  partes = c(1, size_parte)
  for (i in 2:n_cv){
    partes[i+1] <- as.integer(size_parte*i)
  }
  #bota no teste os referentes da intereção n
  ID_test = c(partes[n_interacao]:partes[n_interacao+1])
  test = df %>% filter(ID %in% ID_test)
  #e filtra por aqueles que não estão no teste
  train = df %>% filter(!ID %in% ID_test)
  return(list("train" = train,
              "test" = test))
}

cv_split = function(df, n_cv, n_interacao){
  #Definindo semente
  set.seed(42)
  #pega o número de linhas
  length_df = nrow(df)
  #embaralha os numeros de linhas e embaralha o banco
  rows <- sample(length_df)
  df = df[rows,]
  #Cria indice pra cada linha
  df = df %>% mutate(index_row = seq(1,length_df))
  #define o tamanho da parte
  size_parte = as.integer(length_df/n_cv)
  #pega os threshold
  partes = c(1, size_parte)
  for (i in 2:n_cv){
    partes[i+1] <- as.integer(size_parte*i)
  }
  #bota no teste os referentes da intereção n
  test = df[partes[n_interacao]:partes[n_interacao+1],]
  #Pega os index das linhas do teste
  ID_test = test$index_row
  #e filtra por aqueles que não estão no teste
  train = df %>% filter(!index_row %in% ID_test)
  return(list("train" = train,
              "test" = test))
}

calc_acuracia = function(score,resp,n_cv){
  acuracias_list = NULL
  for (i in seq(0.01,1,0.005)){
    conf_matrix = table(resp,score > i)
    acuracia = round((conf_matrix[4] + conf_matrix[1])/length(resp),3)
    acuracias_list= rbind(acuracias_list,c(acuracia, i,n_cv))
  }
  return(acuracias_list)
}

calc_tvp_tfp = function(score, resp, n_cv){
  roc_table = NULL
  for (i in seq(0,1,0.05)){
    conf_matrix = table(resp,score > i)
    fpr = conf_matrix[3]/(conf_matrix[1] + conf_matrix[3])
    tpr = conf_matrix[4]/(conf_matrix[4] + conf_matrix[2])
    roc_table = rbind(roc_table,c(fpr,tpr,n_cv))
  }
  colnames(roc_table) = c("fpr","tpr","n_cv")
  return(roc_table)
}
```


```{r dados summary}
#carragando os dados e manipulando dados - df_summary
{path = "C:/Users/Windows 10/Desktop/ESTUDOS/data/rodrigo_derived.csv"
df = read_csv(path, na = "-99999") 

#Selecionando o intervalo de [-7,21] e variÃ¡veis
df = df %>% 
            dplyr::select(ID,DIM,PREFR,DDRY,NCALF,Yield,Fat,
                          Protein,Lactose,Blood,SCC,RestTime,RestBout,
                          RestPerBout,Activity,RumLast24, EatLast24,
                          PL_METDIG,PL_MAST_ALL,PL_LAME_ALL,PDOPN,PTBRD,
                          PDCC,AFCDA,PDIM, SICK_ALL) %>%
  rename(DiasLac = DIM,
         DiasSecos = DDRY,
         DiasRegimeFechado = PREFR,
         NumBezerro = NCALF,
         ProdLeite_k1 = Yield,
         Gordura = Fat,
         Proteina = Protein,
         Sangue = Blood,
         NumCelSomaticas = SCC,
         TempoRepouso = RestTime,
         NumRespousos = RestBout,
         DuracaoMediaRepouso = RestPerBout,
         Atividade = Activity,
         RuminacaoUltimas24h_k1 = RumLast24,
         AlimentacaoUltimas24h_k1 = EatLast24,
         Hist_DistDigestivo = PL_METDIG,
         Hist_Mastite = PL_MAST_ALL,
         Hist_Claudicacao = PL_LAME_ALL,
         DiasNaoGravida = PDOPN,
         NInseminada = PTBRD,
         DuracaoGestacao = PDCC,
         DiasPrimeiraParicao = AFCDA,
         DuracaoLacAnterior =  PDIM)  
         


df$SICK_ALL = as.factor(df$SICK_ALL)

# ggplot(df, aes(DiasLac, ProdLeite_k1, col = SICK_ALL)) +
#   geom_point(alpha = 0.5) +
#   scale_color_manual(values = c("lightgrey","#1f77b4"))+
#   theme_bw() +
#   ylab("Produção de Leite (gr)") +
#   xlab("Dias em Lactação") + 
#   geom_vline(xintercept = 0, col = "black", alpha = 0.3) +
#   annotate("text",x = -1, y = 75000, label = "Dia do Parto", col = "black", size = 2,angle = 90)+
#   theme(legend.position = "none") + 
#   annotate("rect", xmin = -3, xmax = 4, ymin = 0, ymax = 100000,
#         alpha = .2, fill = "green") + 
#   annotate("rect", xmin = 4, xmax = 21, ymin = 0, ymax = 100000,
#         alpha = .2, fill = "darkgrey") +
#   annotate("text",x = -1, y = 45000, label = "Período para o cálculo\ndas medidas resumos", col = "black", size = 2)+
#   annotate("text",x = 12, y = 60000, label = "Período de maior incidência\nde distúrbios de saúde", col = "black", size = 2)

df_per = df %>% filter(DiasLac %in% seq(-7,21))
df_per$ID = as.factor(df_per$ID)

#new
#Algumas temperaturas parecem estar multiplicadas por 1000
#df_per$Media_temp_NaoAjustadaAgua_Ultimas24h[which(df_per$Media_temp_NaoAjustadaAgua_Ultimas24h  > 300)] =  #df_per$Media_temp_NaoAjustadaAgua_Ultimas24h[which(df_per$Media_temp_NaoAjustadaAgua_Ultimas24h  > 300)]/1000

#df_per$Media_temp_AjustadaAgua_Ultimas24h[which(df_per$Media_temp_AjustadaAgua_Ultimas24h  > 300)] =
#  df_per$Media_temp_AjustadaAgua_Ultimas24h[which(df_per$Media_temp_AjustadaAgua_Ultimas24h  > 300)]/1000


#Criando variÃ¡vel get_sick
get_sick = df_per %>%
  filter(DiasLac %in% seq(5,21)) %>%
  group_by(ID) %>%
  summarise(get_sick = as.factor(max(as.double(as.character(SICK_ALL))))) %>%
  drop_na() 

#Juntando a variável get_sick ao banco
df_per = df_per %>% left_join(get_sick) #%>% dplyr::select(-SICK_ALL) 

#Colocando NA no leite antes do parto
for (i in 6:11){
  df_per[,i][df_per$DiasLac <= -1,] <- NA
}

#substituindo Rest igual a zero por NA
df_per$TempoRepouso[df_per$TempoRepouso == -1] <- NA
df_per$NumRespousos[df_per$NumRespousos == -1] <- NA
df_per$DuracaoMediaRepouso[df_per$DuracaoMediaRepouso == -1]<- NA


#dados resumos
df_summary = df_per %>%
  filter(DiasLac %in% seq(-3,4)) %>%
  group_by(ID) %>%
  summarise(across(where(is.double), list(mean = ~mean(.x, na.rm = TRUE)),.names = "{.col}.media")) %>%
  left_join(get_sick) %>%
  ungroup() %>%
  #tirei o número de filhotes e se morreu ou não
  dplyr::select(-c(DiasLac.media, NumBezerro.media))


#corrigindo erros historico
df_summary$Hist_Claudicacao.media[is.nan(df_summary$Hist_Claudicacao.media)] <- 0
df_summary$Hist_DistDigestivo.media[is.nan(df_summary$Hist_DistDigestivo.media)] <- 0
df_summary$Hist_Mastite.media[is.nan(df_summary$Hist_Mastite.media)] <- 0

#transformando variaveis
df_summary$Hist_Claudicacao.media = as.factor(df_summary$Hist_Claudicacao.media)
df_summary$Hist_DistDigestivo.media  = as.factor(df_summary$Hist_DistDigestivo.media )
df_summary$Hist_Mastite.media = as.factor(df_summary$Hist_Mastite.media)

#Há vacas que não tem dados, vou subistituir pela mediana da coluna
for (i in 3:ncol(df_summary)){
  df_summary[,i][is.na(df_summary[,i])] <- median(as.numeric(unlist(df_summary[,i])), na.rm = T)
}
}
```



```{r, fig.cap = "Produção de leite entre os dias em torno do parto. A cor azul indica distúrbio de saúde e o cinza, estado saudável."}
ggplot(df, aes(DiasLac, ProdLeite_k1, col = SICK_ALL)) +
  geom_point(alpha = 0.5) +
  scale_color_manual(values = c("lightgrey","#1f77b4"))+
  theme_bw() +
  ylab("Produção de Leite (gr)") +
  xlab("Dias em Lactação") + 
  geom_vline(xintercept = 0, col = "black", alpha = 0.3) +
  annotate("text",x = -1, y = 75000, label = "Dia do Parto", col = "black", size = 2,angle = 90)+
  theme(legend.position = "none") + 
  annotate("rect", xmin = -3, xmax = 4, ymin = 0, ymax = 100000,
        alpha = .2, fill = "green") + 
  annotate("rect", xmin = 4, xmax = 21, ymin = 0, ymax = 100000,
        alpha = .2, fill = "darkgrey") +
  annotate("text",x = -1, y = 45000, label = "Período para o cálculo\ndas medidas resumos", col = "black", size = 2)+
  annotate("text",x = 12, y = 60000, label = "Período de maior incidência\nde distúrbios de saúde", col = "black", size = 2)

#df %>% filter(DiasLac %in% seq(20,25)) %>% summarise(mean(as.numeric(SICK_ALL) - 1, na.rm = T))
```


Para a primeira parte ajustamos o modelo em (1). Caso a vaca tenha ficado doente pelo menos uma vez neste período, a variável resposta $Y_i = 1$ e caso contrário, $Y_i = 0$. Neste modelo, para todo $j$ a variável $x_{ij}$ do modelo em (1) corresponde à média da variável $j$ no período 3 dias antes e 4 dias depois do parto.

Utilizando essa abordagem, aproximadamente um terço das vacas estudadas apresentaram pelo menos um distúrbio de saúde no período entre 5 e 20 dias após o parto.

O modelo em (1) foi ajustado inicialmente considerando todas as covariáveis disponíveis da Tabela 1 e 2 na forma escalar. O método \textit{stepwise} foi empregado para a seleção de covariáveis, pois há uma quantidade considerável de variáveis explanatórias no conjunto de dados, o que dificulta a interpretação dos parâmetros e aumenta o risco de multicolinearidade. A partir de \textit{stepwise} tendo como critério o AIC, o modelo com menor AIC foi escolhido como melhor opção para essa Seção 3.1, pois apresentou acurácia e área sob a curva da ROC maiores que o modelo com todas as covariáveis. 

Após a seleção das variáveis por meio de stepwise, o conjunto de dados foi repartido 10 vezes para realização da validação cruzada com o intuito de testar a capacidade preditiva do modelo. Cada uma das iterações da validação cruzada  a curva ROC e a acurácia para cada uma das iterações da validação cruzada, as quais encontram-se na Figura 3. Para calcular a acurácia, utilizamos um valor de corte que define se a observação será classificado como doente ou não doente baseado na probabilidade $p_i$ de (1). Se a observação i apresentou $p_i$ menor que o valor de corte, esta foi classificado como não doente, e se a obsevação i apresentou $p_i$ maior que o valor de corte, esta foi classificada como doente.

Podemos ver que pela Figura 3 que o modelo tem uma acurácia em média de 62,5% a 75,0% em seu ápice, em torno de um corte igual a 0,4. Já as curvas ROC possui uma área sob a curva de 0,735, implicando uqe há 73,5% de chance que o modelo será capaz de distinguir entre animais doentes e não doentes.


```{r modelagem summary}

{
  v = 10
  area_summary = NULL
  acuracia_summary = NULL
  #perc_doente_summary = NULL
  score_list_summary = NULL
  resp_list_summary = NULL
  ID_list_summary = NULL
  stat_vacas_summary = NULL
  for (i in 1:v){
    df_summary_cv = cv_split(df_summary, v, i)
    mol_summary = glm(get_sick ~ DiasSecos.media +
                        Gordura.media +
                        Proteina.media +
                        TempoRepouso.media +
                        NumRespousos.media +
                        RuminacaoUltimas24h_k1.media +
                        AlimentacaoUltimas24h_k1.media +
                        DiasNaoGravida.media +
                        DuracaoLacAnterior.media,
                        df_summary_cv$train, family = "binomial")
    
    #perc_doente_summary[i] = mean(as.numeric(df_summary_cv$test$doente_amanha)-1)
    score = predict(mol_summary, newdata = df_summary_cv$test,type = "response")
    resp = df_summary_cv$test$get_sick
    area_summary= c(area_summary, round(auc(roc(score,resp)),3))
    #hist(score)
    #sep_hist <- readline(prompt="separate value: ")
    tabela_cont = table(score > 0.2,resp)
    acuracia__summary = c(acuracia_summary,round((tabela_cont[4] + tabela_cont[1])/length(resp),3))
    score_list_summary = cbind(score_list_summary,score)
    resp_list_summary = cbind(resp_list_summary, resp)
    ID_list_summary = cbind(ID_list_summary,df_summary_cv$test$ID)
    
    #ID_vezesDoentes = df_gam %>% select(ID, soma_vezes_doentes_sep) %>% distinct()
    output_mol_summary = as.data.frame(cbind(ID_list_summary[,i],score_list_summary[,i],(resp_list_summary[,i]-1), 1))
    colnames(output_mol_summary) = c("ID","score",'resp', 'int')
    output_mol_summary = output_mol_summary %>% mutate(pred = ifelse((score > 0.5) , 1, 0))
    output_mol_summary = output_mol_summary %>% mutate(pred_correto = ifelse((pred == resp) , 1, 0))
    output_mol_summary$ID = as.factor(output_mol_summary$ID)
    #stat_vacas = as.data.frame(rbind(stat_vacas,output_mol1 %>%
      #group_by(soma_vezes_doentes_sep) %>%
      #summarise(acuracia = mean(pred_correto), total_obs=n(), total_animais = n()/21, int = i)))
  }
}

```


```{r, fig.width=9,fig.height=4, fig.cap="Curvas ROC e acurácias do modelo sem medidas repetidas alcançado por stepwise obtidas por meio de validação cruzada."}
#dev.off()
rocs = NULL
for(i in 1:v){
  rocs = rbind(rocs,calc_tvp_tfp(score_list_summary[,i], as.factor(resp_list_summary[,i]-1),i))
  rocs = as.data.frame(rocs)
  rocs = rbind(rocs, c(1, 1, i))
}

AUC_summary = ggplot(rocs, aes(fpr,tpr, colour = as.factor(n_cv))) +
  geom_line() +
  geom_abline(intercept = 0, slope = 1, linetype=2) +
  #geom_vline(xintercept = 0.1, alpha = 0.3) +
  xlab("Taxa de falso positivo") +
  ylab("Taxa de verdadeiro positivo") +
  ylim(c(0,1.0))+
  xlim(c(0,1.0))+
  annotate(geom="text", x=0.6, y=0.1, col="#1FB477", 
           label=paste("Média das áreas sob a curvas = ",round(mean(c(area_summary)),3))) +
  annotate(geom = "text", x = 0.5, y = 0.45, label = "Classificador Aleatório", color = "black",
           angle = 40)+
  theme_bw()+
  theme(legend.position = 'none')

#Acurácia
acuracias = NULL
for(i in 1:v){
  acuracias = rbind(acuracias, c(mean(resp_list_summary[,i]-1),0, i))
  acuracias = rbind(acuracias,calc_acuracia(score_list_summary[,i], as.factor(resp_list_summary[,i]-1),i))
  acuracias = as.data.frame(acuracias)
  acuracias = acuracias %>% drop_na()
  acuracias = rbind(acuracias, c((acuracias %>% dplyr::select(V1) %>% tail(1) %>% as.numeric()),1, i))
}

colnames(acuracias) = c('acuracia','corte','cv')

acuracias = acuracias %>% drop_na() %>% filter(acuracia < 0.9)

acuracia_summary = ggplot(acuracias, aes(corte,acuracia, colour = as.factor(cv))) +
  geom_line() +
  xlab("Corte") +
  ylab("Acurácia") +
  ylim(c(0,1.0))+
  xlim(c(0,1.0))+
  theme_bw()+
  theme(legend.position = 'none')


AUC_summary + acuracia_summary
```

A partir do ajuste do modelo final (modelo com menor AIC), os resultados na Tabela 3 mostram que um aumento média de porcentagem de gordura no leite e o número médio de dias que o estado da vaca não está grávida aumentam a probabilidade do animal apresentar um distúrbio de saúde após o parto, pois o efeito estimado das covariáveis é positivo. Já um aumento na quantidade média de proteína no leite, o tempo médio de repouso, o tempo médio de ruminação e a média alimentação diminuem a probabilidade do animal ter um problema de saúde, já que o efeito estimado das covariáveis é negativo.

```{r tabela summary}
mol_summary = glm(get_sick ~ DiasSecos.media +
                        Gordura.media +
                        Proteina.media +
                        TempoRepouso.media +
                        NumRespousos.media +
                        RuminacaoUltimas24h_k1.media +
                        AlimentacaoUltimas24h_k1.media +
                        DiasNaoGravida.media +
                        DuracaoLacAnterior.media,
                        df_summary, family = "binomial")

broom::tidy(mol_summary) %>% mutate_if(is.numeric, round, 3) %>%
  mutate(term=replace(term, term=="(Intercept)", "Intercepto")) %>%
  mutate(term=replace(term, term=="RuminacaoUltimas24h_k1.media", "RuminacaoUltimas24h.media")) %>%
  mutate(term=replace(term, term=="AlimentacaoUltimas24h_k1.media", "AlimentacaoUltimas24h.media")) %>%
  mutate(p.value=replace(p.value, p.value < 0.05, "<0,05")) %>%
  kable(caption = "Resultados do ajuste do modelo sem medidas repetidas obtido por stepwise.", col.names = c("Termo","Estimativa","Erro padrão","Estatística do teste","P-valor")) %>%
  kable_styling(position = "center",latex_options = "HOLD_position")
```


## 4.2 Resultados do ajuste do modelo com medidas repetidas de saúde da vaca

Ajustamos o modelo (2) considerando duas abordagens: uma delas considera as variáveis somente na forma escalar e a outra considera as variáveis na forma escalar ou funcional. Como o processamento computacional para o ajuste desses modelos é alto, principalmente com o uso de variáveis na forma funcional, consideramos como covariáveis a ruminação, alimentação e estados de saúde dos dois dias antereiores, pois mostraram-se significativas no modelo da Seção 4.1 e apresentaram-se serem promissoras na análise exploratória. Além disso, nas duas abordagens um efeito aleatório para cada vaca foi considerado para acomodar a correlação entre as medidas do animal. Chamaremos o modelo da primeira abordagem como modelo misto escalar (MME) e o da segunda de modelo misto escalar-funcional (MMEF).  

Para predizer o estado do animal no dia $k$, do ponto de vista biológico, fez sentido considerar o efeito das covariáveis sobre o estado de saúde do animal que foram medidas no dia $k-1$ e $k-2$. Não ocorreu nenhuma melhora significativa ao utilizar dias anteriores à $k-2$. Sendo assim, para o modelo em (2), consideramos o estado do animal $i$ no dia $k$ como função das covariáveis $x_{i,1,(k-1, k-2)},\dots x_{i,J,(k-1, k-2)}$. Desta forma, para o dia do parto utilizamos informações das variáveis medidas nos dois dias anteriores e assim sucessivamente até o vigésimo dia após o parto. Escolheu-se esse ponto de parada, pois, após o vigésimo dia, os distúrbios de saúde representam cerca de apenas 1% das observações, o que dificulta a modelagem e a predição.

Como utilizou-se informações de dias diferentes para realizar a predição do estado de saúde, logo foi possível adicionar ao modelo a interação entre variáveis de mesma natureza desses dias, por exemplo, interação entre estado de saúde no dia $k-1$ e $k-2$.

As curvas ROC e a acurácias do MME obtidas por meio de validações cruzadas indicam que o poder de classificação do modelo é bastante satisfatório, pois a área sob a curva e a acurácia estão próximas de 0,9, como mostra a Figura 4. 


```{r df gam}
{
  path = "C:/Users/Windows 10/Desktop/ESTUDOS/data/rodrigo_derived.csv"

df = read_csv(path, na = "-99999") 

df = df %>% 
  dplyr::select(ID,DIM,PREFR,DDRY,NCALF,Yield,Fat,
                Protein,Lactose,Blood,SCC,RestTime,RestBout,
                RestPerBout,Activity,RumLast24, EatLast24,
                PL_METDIG,PL_MAST_ALL,PL_LAME_ALL,PDOPN,PTBRD,
                PDCC,AFCDA,PDIM, SICK_ALL) %>%
  rename(DiasLac = DIM,
         DiasSecos = DDRY,
         DiasRegimeFechado = PREFR,
         NumBezerro = NCALF,
         ProdLeite_k1 = Yield,
         Gordura = Fat,
         Proteina = Protein,
         Sangue = Blood,
         NumCelSomaticas = SCC,
         TempoRepouso = RestTime,
         NumRespousos = RestBout,
         DuracaoMediaRepouso = RestPerBout,
         Atividade = Activity,
         RuminacaoUltimas24h_k1 = RumLast24,
         AlimentacaoUltimas24h_k1 = EatLast24,
         Hist_DistDigestivo = PL_METDIG,
         Hist_Mastite = PL_MAST_ALL,
         Hist_Claudicacao = PL_LAME_ALL,
         DiasNaoGravida = PDOPN,
         NInseminada = PTBRD,
         DuracaoGestacao = PDCC,
         DiasPrimeiraParicao = AFCDA,
         DuracaoLacAnterior =  PDIM)  

df$SICK_ALL = as.factor(df$SICK_ALL)

df_per = df %>% filter(DiasLac %in% seq(-7,21))
df_per$ID = as.factor(df_per$ID)

df_per_red = df_per %>% dplyr::select(DiasLac,ID,Gordura,Proteina, DuracaoMediaRepouso,
                                      RuminacaoUltimas24h_k1, AlimentacaoUltimas24h_k1, ProdLeite_k1,
                                      SICK_ALL) %>%
  filter(DiasLac %in% seq(0,20))

#Proximo dia
df_per_red = df_per_red %>%
  group_by(ID) %>%
  mutate(doente_amanha = dplyr::lead(SICK_ALL, n = 1, default = NA),
         doente_k2 = dplyr::lag(SICK_ALL, default = NA),
         ProdLeite_k2 = dplyr::lag(ProdLeite_k1, default = NA),
         Gordura_ontem = dplyr::lag(Gordura, default = NA),
        RuminacaoUltimas24h_k2= dplyr::lag(RuminacaoUltimas24h_k1, default = NA),
         AlimentacaoUltimas24h_k2 = dplyr::lag(AlimentacaoUltimas24h_k1, default = NA))

#Eliminando obs faltantes
df_gam = df_per_red %>%
  group_by(ID) %>%
  mutate_all(funs(ifelse(is.na(.), mean(., na.rm = TRUE),.))) %>%
  ungroup() %>%
  mutate_all(funs(ifelse(is.na(.), median(., na.rm = TRUE),.)))

#Convertando
df_gam$doente_amanha = as.factor(df_gam$doente_amanha - 1)
df_gam$doente_k2 = as.factor(df_gam$doente_k2 - 1)
df_gam$SICK_ALL = as.factor(df_gam$SICK_ALL - 1)
df_gam$ID = as.factor(df_gam$ID)

#Repouso -1 = 0
df_gam$DuracaoMediaRepouso[df_gam$DuracaoMediaRepouso <= -1] = 0

df_gam = df_gam %>% rename(doente_k1 = SICK_ALL)


#Quantidade de vezes que as vacas ficaram doentes
#df_gam %>%
#  group_by(ID) %>%
#  summarise(soma_vezes_doentes = sum(as.numeric(doente_amanha)-1)) %>%
#  ungroup() %>%
#  group_by(soma_vezes_doentes) %>%
#  tally()

#Quantidade 
df_gam = df_gam %>% 
  group_by(ID) %>%
  mutate(soma_vezes_doentes = sum(as.numeric(doente_amanha)-1))

#Quantidade de vezes que as vacas ficaram doentes por períodos
df_gam[df_gam$soma_vezes_doentes == 0,"soma_vezes_doentes_sep"] = '0'
df_gam[df_gam$soma_vezes_doentes >=1 & df_gam$soma_vezes_doentes <= 5,"soma_vezes_doentes_sep"] = "1 a 5"
df_gam[df_gam$soma_vezes_doentes >=6 & df_gam$soma_vezes_doentes <= 10,"soma_vezes_doentes_sep"] = "6 a 10"
df_gam[df_gam$soma_vezes_doentes >=11 & df_gam$soma_vezes_doentes <= 15,"soma_vezes_doentes_sep"] = "11 a 15"
df_gam[df_gam$soma_vezes_doentes >=16 & df_gam$soma_vezes_doentes <= 21,"soma_vezes_doentes_sep"] = "> 15"

df_gam$soma_vezes_doentes_sep = as.character(df_gam$soma_vezes_doentes_sep)


#ID vezes doente distinct
ID_vezesDoentes = df_gam %>% dplyr::select(ID, soma_vezes_doentes_sep) %>% distinct()

#Quantidade de vacas que ficaram doentes separado por período
df_gam$soma_vezes_doentes_sep = factor(df_gam$soma_vezes_doentes_sep,
                                           levels = c("0", "1 a 5", "6 a 10", "11 a 15", "> 15"))

#df_gam %>%
#  distinct(ID,.keep_all = TRUE) %>%
#  group_by(soma_vezes_doentes_sep) %>%
#  tally()
}
```

```{r modelagem esc,results='hide',comment=NA}
{
  v = 10
  area_cv_pleno_func_ar1 = NULL
  acuracia_cv_pleno_func_ar1 = NULL
  #perc_doente = NULL
  score_list = NULL
  resp_list = NULL
  ID_list = NULL
  stat_vacas = NULL
  for (i in 1:v){
    df_cv_pleno_func_ar1 = cv_pleno(df_gam, n_cv = v,n_interacao = i, "ID")
    mol1 = gamm(doente_amanha ~ #Gordura +
                  #Gordura_ontem +
                  RuminacaoUltimas24h_k1 * 
                  RuminacaoUltimas24h_k2+
                  AlimentacaoUltimas24h_k1 *
                  AlimentacaoUltimas24h_k2 +
                  doente_k1 * 
                  doente_k2 +
                  #ProdLeite_k1 *
                  #ProdLeite_k2 +
                  #DuracaoMediaRepouso +
                  #DiasNaoGravida+ 
                  DiasLac,
                  family="binomial",
                data=df_cv_pleno_func_ar1$train,
                random=list(ID=~1),
                method = "REML")
    
    #perc_doente[i] = mean(as.numeric(df_cv_pleno_func_ar1$test$doente_amanha)-1)
    score = predict(mol1$gam, newdata = df_cv_pleno_func_ar1$test,type = "response")
    resp = df_cv_pleno_func_ar1$test$doente_amanha
    area_cv_pleno_func_ar1 = c(area_cv_pleno_func_ar1, round(auc(roc(score,resp)),3))
    #hist(score)
    #sep_hist <- readline(prompt="separate value: ")
    tabela_cont = table(score > 0.2,resp)
    acuracia_cv_pleno_func_ar1 = c(acuracia_cv_pleno_func_ar1,round((tabela_cont[4] + tabela_cont[1])/length(resp),3))
    score_list = cbind(score_list,score)
    resp_list = cbind(resp_list, resp)
    ID_list = cbind(ID_list,df_cv_pleno_func_ar1$test$ID)
    
    ID_vezesDoentes = df_gam %>% dplyr::select(ID, soma_vezes_doentes_sep) %>% distinct()
    output_mol1 = as.data.frame(cbind(ID_list[,i],score_list[,i],(resp_list[,i]-1), 1))
    colnames(output_mol1) = c("ID","score",'resp', 'int')
    output_mol1 = output_mol1 %>% mutate(pred = ifelse((score > 0.3) , 1, 0))
    output_mol1 = output_mol1 %>% mutate(pred_correto = ifelse((pred == resp) , 1, 0))
    output_mol1$ID = as.factor(output_mol1$ID)
    output_mol1 = output_mol1 %>% inner_join(ID_vezesDoentes)
    stat_vacas = as.data.frame(rbind(stat_vacas,output_mol1 %>%
      group_by(soma_vezes_doentes_sep) %>%
      summarise(acuracia = mean(pred_correto), total_obs=n(), total_animais = n()/21, int = i)))
  }
}


#table(output_mol1$soma_vezes_doentes_sep, output_mol1$sum_pred)

#output_mol1_distinct = output_mol1 %>%
#  dplyr::select(ID, soma_vezes_doentes, sum_pred) %>%
#  distinct()

#vzsDoentes_vzsPred = table(output_mol1_distinct$soma_vezes_doentes, output_mol1_distinct$sum_pred)


#9-10% das observações são doentes
#perc_doente
#mean(perc_doente)


#summary(mol1$gam)

#mean(acuracias[acuracias$corte == 0.4,]$acuracia)
```


```{r AUC e acurácia esc, fig.width=9,fig.height=4,fig.cap="Curvas ROC e acurácias do MME obtidas por meio de validação cruzada."}
#ROC curve
rocs = NULL
for(i in 1:v){
  rocs = rbind(rocs,calc_tvp_tfp(score_list[,i], as.factor(resp_list[,i]-1),i))
  rocs = as.data.frame(rocs)
  rocs = rbind(rocs, c(1, 1, i))
}

AUC_pleno = ggplot(rocs, aes(fpr,tpr, colour = as.factor(n_cv))) +
  geom_line() +
  geom_abline(intercept = 0, slope = 1, linetype=2) +
  #geom_vline(xintercept = 0.1, alpha = 0.3) +
  xlab("Taxa de falso positivo") +
  ylab("Taxa de verdadeiro positivo") +
  ylim(c(0,1.0))+
  xlim(c(0,1.0))+
  annotate(geom="text", x=0.6, y=0.1, col="#1FB477", 
           label=paste("Média das áreas sob a curvas = ", 0.927)) +
  annotate(geom = "text", x = 0.5, y = 0.45, label = "Classificador Aleatório",
           color = "black",
           angle = 40)+
  theme_bw()+
  theme(legend.position = 'none')

#Acurácia
acuracias = NULL
for(i in 1:v){
  acuracias = rbind(acuracias, c(mean(resp_list[,i]-1),0, i))
  acuracias = rbind(acuracias,calc_acuracia(score_list[,i], as.factor(resp_list[,i]-1),i))
  acuracias = as.data.frame(acuracias)
  #acuracias = rbind(acuracias, c(1, 1, i))
  acuracias = acuracias %>% drop_na()
  acuracias = rbind(acuracias, c((acuracias %>% dplyr::select(V1) %>% tail(1) %>% as.numeric()),1, i))
}

colnames(acuracias) = c('acuracia','corte','cv')

acuracia_pleno = ggplot(acuracias, aes(corte,acuracia, colour = as.factor(cv))) +
  geom_line() +
  xlab("Corte") +
  ylab("Acurácia") +
  ylim(c(0,1.0))+
  xlim(c(0,1.0))+
  theme_bw()+
  theme(legend.position = 'none')


AUC_pleno + acuracia_pleno
```

Para o MMEF, a variável referente aos dias de lactação foi utilizada como funcional. Entre o dia do parto até quinto dia após esse evento, 5,4% das observações são doentes. Entre o quinto e o décimo dia, 16,7% são doentes. Entre o décimo e o décimo quinto, 11,4% são doentes. E entre o décimo quinto e o vigésimo dia após o parto, apenas 4,8% são observações doentes, o que indicia a aparente não linearidade dessa variável em relação ao estado de saúde dos animais. Logo, nesse caso, uma variável referente aos dias de lactação do tipo funcional se encaixa melhor no modelo. As outras variáveis apresentaram comportamentos lineares quando analisadas separadamente em um modelo individual, ou seja, apenas com uma variável. Logo, elas foram mantidas na forma escalar.

As curvas ROC e a acurácia do MMEF, apresentados na Figura 5, apontam que a capacidade de predição é muito boa, pois ambas das métricas usadas apresentaram serem maiores que 0,9, indicando um bom poder preditivo que supera o do MME em 0,007 na média da área sob a curva e 0,0012 na média de acurácia, respectivamente. 


```{r ajuste esc,comment=NA}
#Ctrl + shift + C
# mol1 = gamm(doente_amanha ~ #Gordura +
#                   #Gordura_ontem +
#                   RuminacaoUltimas24h_k1 * 
#                  RuminacaoUltimas24h_k2+
#                   AlimentacaoUltimas24h_k1 *
#                   AlimentacaoUltimas24h_k2 +
#                   doente_k1 * 
#                   doente_k2 + 
#                   ProdLeite_k1 *
#                   ProdLeite_k2 +
#                   #DuracaoMediaRepouso +
#                   #DiasNaoGravida+ 
#                   DiasLac,
#                   family="binomial",
#                 data=df_gam,
#                 random=list(ID=~1),
#                 method = "REML")
# 
# mol1_gam = summary.gam(mol1$gam)
# 
# kable(as.data.frame(mol1_gam$p.table) %>% tibble::rownames_to_column("term") %>%
#         mutate_if(is.numeric, round, 3) %>%
#         mutate(term=replace(term, term == "(Intercept)", "Intercepto")) %>%
#         mutate(term=replace(term, term == "SICK_ALL1", "doente_k2")) %>%
#         mutate(`Pr(>|t|)`=replace(`Pr(>|t|)`, `Pr(>|t|)` < 0.001, "<0,001"))%>%
#         mutate(Estimate=replace(Estimate, Estimate < 0.001, "<0,001")) %>%
#         mutate(`Std. Error`=replace(`Std. Error`, `Std. Error` < 0.001, "<0,001")),
#         caption = "Estimativas dos parâmetros do ajuste do modelo misto escalar.",
#         col.names = c("Termo","Estimativa","Erro padrão","Estatística do teste","P-valor"))  %>%
#   kable_styling(font_size = 10, latex_options = "HOLD_position")
```


```{r modelagem,results='hide',comment=NA}
{
  v = 10
  area_cv_pleno_func_ar1 = NULL
  acuracia_cv_pleno_func_ar1 = NULL
  #perc_doente = NULL
  score_list = NULL
  resp_list = NULL
  ID_list = NULL
  stat_vacas = NULL
  for (i in 1:v){
    df_cv_pleno_func_ar1 = cv_pleno(df_gam, n_cv = v,n_interacao = i, "ID")
    mol1 = gamm(doente_amanha ~ #Gordura +
                  #Gordura_ontem +
                  RuminacaoUltimas24h_k1 * 
                  RuminacaoUltimas24h_k2+
                  AlimentacaoUltimas24h_k1 *
                  AlimentacaoUltimas24h_k2 +
                  doente_k1 * 
                  doente_k2 + 
                  ProdLeite_k1 *
                  ProdLeite_k2 +
                  #DuracaoMediaRepouso +
                  #DiasNaoGravida+ 
                  s(DiasLac, bs = 'cr'),
                  family="binomial",
                data=df_cv_pleno_func_ar1$train,
                random=list(ID=~1),
                method = "REML")
    
    #perc_doente[i] = mean(as.numeric(df_cv_pleno_func_ar1$test$doente_amanha)-1)
    score = predict(mol1$gam, newdata = df_cv_pleno_func_ar1$test,type = "response")
    resp = df_cv_pleno_func_ar1$test$doente_amanha
    area_cv_pleno_func_ar1 = c(area_cv_pleno_func_ar1, round(auc(roc(score,resp)),3))
    #hist(score)
    #sep_hist <- readline(prompt="separate value: ")
    tabela_cont = table(score > 0.2,resp)
    acuracia_cv_pleno_func_ar1 = c(acuracia_cv_pleno_func_ar1,round((tabela_cont[4] + tabela_cont[1])/length(resp),3))
    score_list = cbind(score_list,score)
    resp_list = cbind(resp_list, resp)
    ID_list = cbind(ID_list,df_cv_pleno_func_ar1$test$ID)
    
    ID_vezesDoentes = df_gam %>% dplyr::select(ID, soma_vezes_doentes_sep) %>% distinct()
    output_mol1 = as.data.frame(cbind(ID_list[,i],score_list[,i],(resp_list[,i]-1), 1))
    colnames(output_mol1) = c("ID","score",'resp', 'int')
    output_mol1 = output_mol1 %>% mutate(pred = ifelse((score > 0.3) , 1, 0))
    output_mol1 = output_mol1 %>% mutate(pred_correto = ifelse((pred == resp) , 1, 0))
    output_mol1$ID = as.factor(output_mol1$ID)
    output_mol1 = output_mol1 %>% inner_join(ID_vezesDoentes)
    stat_vacas = as.data.frame(rbind(stat_vacas,output_mol1 %>%
      group_by(soma_vezes_doentes_sep) %>%
      summarise(acuracia = mean(pred_correto), total_obs=n(), total_animais = n()/21, int = i)))
  }
}


#table(output_mol1$soma_vezes_doentes_sep, output_mol1$sum_pred)

#output_mol1_distinct = output_mol1 %>%
#  dplyr::select(ID, soma_vezes_doentes, sum_pred) %>%
#  distinct()

#vzsDoentes_vzsPred = table(output_mol1_distinct$soma_vezes_doentes, output_mol1_distinct$sum_pred)


#9-10% das observações são doentes
#perc_doente
#mean(perc_doente)


#summary(mol1$gam)
```


```{r AUC e acurácia, fig.width=9,fig.height=4,fig.cap="Curvas ROC e acurácias do MMEF obtidas por meio de validação cruzada."}
#ROC curve
rocs = NULL
for(i in 1:v){
  rocs = rbind(rocs,calc_tvp_tfp(score_list[,i], as.factor(resp_list[,i]-1),i))
  rocs = as.data.frame(rocs)
  rocs = rbind(rocs, c(1, 1, i))
}

AUC_pleno = ggplot(rocs, aes(fpr,tpr, colour = as.factor(n_cv))) +
  geom_line() +
  geom_abline(intercept = 0, slope = 1, linetype=2) +
  #geom_vline(xintercept = 0.1, alpha = 0.3) +
  xlab("Taxa de falso positivo") +
  ylab("Taxa de verdadeiro positivo") +
  ylim(c(0,1.0))+
  xlim(c(0,1.0))+
  annotate(geom="text", x=0.6, y=0.1, col="#1FB477", 
           label=paste("Média das áreas sob a curvas = ", round(mean(c(area_cv_pleno_func_ar1)),3))) +
  annotate(geom = "text", x = 0.5, y = 0.45, label = "Classificador Aleatório",
           color = "black",
           angle = 40)+
  theme_bw()+
  theme(legend.position = 'none')

#Acurácia
acuracias = NULL
for(i in 1:v){
  acuracias = rbind(acuracias, c(mean(resp_list[,i]-1),0, i))
  acuracias = rbind(acuracias,calc_acuracia(score_list[,i], as.factor(resp_list[,i]-1),i))
  acuracias = as.data.frame(acuracias)
  #acuracias = rbind(acuracias, c(1, 1, i))
  acuracias = acuracias %>% drop_na()
  acuracias = rbind(acuracias, c((acuracias %>% dplyr::select(V1) %>% tail(1) %>% as.numeric()),1, i))
}

colnames(acuracias) = c('acuracia','corte','cv')

acuracia_pleno = ggplot(acuracias, aes(corte,acuracia, colour = as.factor(cv))) +
  geom_line() +
  xlab("Corte") +
  ylab("Acurácia") +
  ylim(c(0,1.0))+
  xlim(c(0,1.0))+
  theme_bw()+
  theme(legend.position = 'none')


AUC_pleno + acuracia_pleno

#mean(acuracias[acuracias$corte == 0.4,]$acuracia)

#0.9489 - 0.9476667
```


As estimativas dos efeitos escalares do MMEF se encontram na Tabela 4. As variáveis referentes a ruminação durante as últimas 24 horas e estado de saúde nos dois dias anteriores tem efeito positivo no logito, indicando que a probabilidade da vaca ficar doente aumenta quando há um aumento na atividade de ruminação ou se a vaca ficou doente nos dois dias anteriores. A alimentação nas últimas 24 horas tem efeito negativo, indicando que a probabilidade de adoecer diminui quando a vaca está bem alimentada. Além disso, como a estimativa da interação entre o estado de saúde dos dias anteriores tem efeito positivo no logito, isso nos diz que há um aumento na probabilidade de vir a ficar doente quando o animal esteve doente nos dois dias anteriores em comparação à probabilidade de ter estado doente em apenas um dia.

A Figura 6 exibe a curva estimada a variável funcional referente ao dia de lactação. A estimativa dos coeficientes de suavização, $\hat{\theta_p}$, em (3) para a curva de dia de lactação mostrou se estatisticamente significante já que a função estimada $s(DiasLac)$ tem p-valor menor do que 0,001, como descrito na Tabela 5, implicando que não há linearidade na relação entre dia de lactação e probabilidade do animal estar doente.



```{r ajuste esc fun,results='hide', comment = NA}
mol1 = gamm(doente_amanha ~ #Gordura +
                  #Gordura_ontem +
                  RuminacaoUltimas24h_k1 * 
                 RuminacaoUltimas24h_k2+
                  AlimentacaoUltimas24h_k1 *
                  AlimentacaoUltimas24h_k2 +
                  doente_k1 * 
                  doente_k2 +
                  #ProdLeite_k1 *
                  # ProdLeite_k2 +
                  #DuracaoMediaRepouso +
                  #DiasNaoGravida+ 
                  s(DiasLac, bs = 'cr'),
                  family="binomial",
                data=df_gam,
                random=list(ID=~1),
                method = "REML")


```


```{r esc fun table}
mol1_gam = summary.gam(mol1$gam)

tab_esc_fun = as.data.frame(mol1_gam$p.table) %>% tibble::rownames_to_column("term") %>%
        mutate(Estimate=replace(Estimate, is.numeric(Estimate), formatC(Estimate, format = "e", digits = 2))) %>%
        mutate(`Pr(>|t|)`=replace(`Pr(>|t|)`, `Pr(>|t|)` < 0.05, "<0,05")) %>%
        mutate(term=replace(term, term == "(Intercept)", "Intercepto")) %>%
        mutate(term=replace(term, term=="doente_k11", "doente_k1")) %>%
        mutate(term=replace(term, term=="doente_k21", "doente_k2")) %>%
        mutate(term=replace(term, term == "doente_k11:doente_k21", "doente_k1:doente_k2")) %>%
        mutate(term=replace(term, term == "SICK_ALL1", "doente_k2")) %>%
        mutate(`Std. Error`=replace(`Std. Error`, is.numeric(`Std. Error`), round(`Std. Error`, 3)))%>%
        mutate(`t value`=replace(`t value`, is.numeric(`t value`), round(`t value`,3))) %>%
        mutate(`Pr(>|t|)`=replace(`Pr(>|t|)`, is.character(`Pr(>|t|)`), strtrim(`Pr(>|t|)`, 6)))%>% 
  mutate(`Pr(>|t|)`=replace(`Pr(>|t|)`, `Pr(>|t|)` == "0,7099", "0,710")) %>%
  mutate(`Pr(>|t|)`=replace(`Pr(>|t|)`, `Pr(>|t|)` == "0,0798", "0,080")) %>%
  mutate(`Pr(>|t|)`=replace(`Pr(>|t|)`, `Pr(>|t|)` == "0,0990", "0,100")) %>%
  mutate(`Std. Error`=replace(`Std. Error`, `Std. Error` == 0.000, 0.001))#;tab_esc_fun


kable(tab_esc_fun,
        caption = "Estimativas dos parâmetros do ajuste do modelo misto escalar-funcional. Os sufixos k1 e k2 são referentes à k-1 e k-2, respectivamente.",
        col.names = c("Termo","Estimativa","Erro padrão","Estatística do teste","P-valor"))  %>%
  kable_styling(font_size = 10, latex_options = "HOLD_position")


#mutate(Estimate=replace(Estimate, Estimate < 0.001 & Estimate >= 0, "<0,001")) %>%
#mutate(Estimate=replace(Estimate, Estimate > -0.001 & Estimate <= 0, ">-0,001")) %>%
```


```{r lac plot, fig.cap="Curva estimada de dia de lactação (DiasLac)"}
plot(mol1$gam)
```

```{r lac table}
kable(as.data.frame(broom::tidy(mol1$gam) %>% mutate_if(is.numeric, round, 3) %>%
                      dplyr::select(-ref.df) %>%
                      mutate(p.value=replace(p.value, p.value < 0.001, "<0,001"))),
                    caption = "P-valor do efeito da função de suavização s(DiasLac) no modelo misto escalar-funcional. GLE é referente aos graus de liberdade efetivos.",
      col.names = c("Termo","GLE","Estatística do teste","P-valor"))  %>%
  kable_styling(font_size = 10, latex_options = "HOLD_position")
```

Como a maior parte das observações entre o dia do parto até os vinte dias posteriores são de estados de saúde saudáveis, cerca de 90%, logo um modelo que predissesse todas as observações como saudáveis também teria uma acurácia de 90%. Para investigar mais a fundo como ocorre a classificação no MMEF, construiu-se a Figura 7. Ao invés de analisar a acurácia geral do modelo, dividiu-se as observações do teste em intervalos referentes a quantos dias a vaca apresentou ficar doente. Por exemplo, o intervalo 0 contém observações de animais que não ficaram doentes nos dias estudados, já o intervalo de 1 a 5 contém observações de animais que ficaram doentes entre 1 a 5 vezes no período analisado, e assim por diante. Cada ponto mais transparente é a acurácia no intervalo em uma repartição da validação cruzada, já os pontos opacos são a média de acurácia no intervalo no geral. Podemos ver que o modelo possui uma acurácia praticamente perfeita entre as vacas que não ficaram doentes em nenhum dos dias considerados, e cai quando se avança nos intervalos. Entretanto, a média acurácia se manteve maior que 75% nos demais intervalos. Com isso, o modelo ajustado apresenta ser superior a um classificador simplório, i.e. classifica tudo igual, pois ele consegue predizer corretamente, com uma boa acurácia, as observações marcadas com distúrbio de saúde presente.
Na Figura 7, há ainda uma linha demarcando a acurácia média do MMEF no corte que otimiza essa medida. A tabela nessa figura mostra a quantidade média de observações dos intervalos de vezes que as vacas ficaram doentes entre o parto e os 20 dias posteriores em cada envelope da validação cruzada, então, por exemplo, em um envelope há em média 643 observações de animais que não ficaram doentes durante esse período.


```{r plot intervalo, fig.width=9,fig.height=4, fig.cap="Acurácia em intervalos de quantas vezes as vacas do conjunto de teste ficaram doentes entre o dia do parto e os 20 dias posteriores, obtida pela validação cruzada."}
#gráfico da acurácia entre os diferentes intervalos
arrows <-
  tibble(
    x1 = c(1),
    x2 = c(1.5),
    y1 = c(1),
    y2 = c(0.7)
  )

stat_vacas$soma_vezes_doentes_sep = factor(stat_vacas$soma_vezes_doentes_sep,
                                           levels = c("0", "1 a 5", "6 a 10", "11 a 15", "> 15"))

tabela_vacas = stat_vacas %>%
  group_by(soma_vezes_doentes_sep) %>%
  summarise(media_de_observacoes = round(mean(total_obs)))

rownames(tabela_vacas) = NULL

colnames(tabela_vacas) = c('Intervalos', 'Média de n.º observações\nnos envelopes')

acuracia_t = NULL
for (t in 1:v){
  conf_matrix1 = table(resp_list[,t],score_list[,t] > 0.2)
  acuracia_t[t] = round((conf_matrix1[4] + conf_matrix1[1])/length(resp_list[,1]),3)
}

#acuracia_t
#mean(acuracia_t) #0.9473

acuracias_intervalo  = stat_vacas %>% 
  ggplot(aes(soma_vezes_doentes_sep, acuracia, color = soma_vezes_doentes_sep))+
  #geom_boxplot(color = "gray60", outlier.alpha = 0)+
  geom_point(size = 3, alpha = 0.25)+
  geom_hline(aes(yintercept = 0.9473), color = "gray70", size = 0.6) +
  stat_summary(fun = mean, geom = "point", size = 5)+
  geom_curve(
    data = arrows, aes(x = x1, y = y1, xend = x2, yend = y2),
    arrow = arrow(length = unit(0.07, "inch")), size = 0.4,
    color = "gray20", curvature = -0.3
  )+
  annotate(geom = "text", x = 4, y = 0.975,
           label = "Média das acurácias das validações cruzadas = 0.947",
           color = "black", size = 3)+
  annotate(geom = "text", x = 1.5, y = 0.60,
           label = "Como a maioria das vacas não ficaram doentes,\neste intervalo tem mais influência que os outros na\nmédia da acurácia.",
           color = "black", size = 3)+
  xlab("Número de vezes que os animais ficaram doentes entre o parto e 20 dias após o parto")+
  ylab("Acurácia")+
  ylim(c(0,1))+
  annotate(geom = "table", x = 3.8, y = 0.39, label = list(tabela_vacas), 
           vjust = 1, hjust = 0) +
  theme_bw()+
  theme(legend.position = 'none')

acuracias_intervalo
```

\newpage

# 5 Conclusão

Os resultados obtidos neste trabalho apresentam duas abordagens com uso de modelos para predição do estado de saúde animal no contexto do período periparturiente em vacas leiteiras. A escolha de qual abordagem dependerá das exigências do usuário. Se a pessoa interessada querer predizer com uma antecedência maior o estado do animal, é mais provável que ela tenha preferência pela abordagem sem medidas repetidas. Já se a preferência for por um modelo com uma capacidade preditiva maior e a antecedência do resultado curta não seja um empecilho, é mais provável que se opte pelo modelo com medidas repetidas.

# 6 Realizações do período

Durante a segunda quinzena de fevereiro, foi realizado o estudo bibliográfico para validação cruzada, cujas funções foram criadas em março, junto dos gráficos para a checagem da qualidade de predição do modelo. Ainda em março, iniciou-se a escrita do relatório, a qual terminou em junho. Ao longo de todo esse período, ocorreram reuniões semanais com a orientadora, a fim de esclarecer dúvidas gerais sobre o projeto.


\newpage

# Referências bibliográficas